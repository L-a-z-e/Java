제어자 : 클래스, 변수, 메서드의 선언부에 함께 사용되어 부가적인 의미 부여
- 접근제어자 : public, protected, default, private
- 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp

제어자는 여러개를 조합하여 사용가능하지만, 접근제어자는 4개중 1개만 사용가능하다.
static : 클래스의, 공통적인
       - 인스턴스 멤버를 사용하지 않는 메서드만 static 메서드를 사용가능
       - 멤버변수에 사용될 수 있음 -> 클래스변수가 되고 인스턴스를 생성하지 않고도 사용가능
       - 초기화 블럭에 사용가능
final : 마지막의, 변경될 수 없는
    - 클래스, 메서드, 멤버변수, 지역변수에서 사용한다.
    - 변수에 사용되면 값을 변경할 수 없는 상수, 메서드에 사용되면 오버라이딩 금지, 클래스에 사용되면 자손클래스 정의 금지
    - 생성자를 이용해서 final 멤버변수의 초기화를 할 수있음 ex) 카드는 처음 생성될때는 초기화가 필요하지만 이후에는 변경되면 안되므로
      final int NUMBER 를 인스턴스 변수로 갖고있다고 하면
      생성자에 Card(int num) 을 통해 초기화를 해주고 인스턴스 생성시 card.NUMBER = 10; 으로 접근 시 변경 불가하게 처리

abstract : 추상의, 미완성의
    - 사용하는 곳 : 클래스, 메서드
    - 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않음, 클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 알 수 있음
    - 왜 쓰는가? 여러 메서드를 abstract를 안쓰면 나중에 상속받을때 전부 오버라이딩해야하지만 이런경우에는 상속받아서 필요한 메서드만 부분적으로 오버라이딩이 가능하다

접근제어자 : 멤버 또는 클래스에 사용되며, 외부에서 접근하지 못하도록 제어하는 역할
    - private : 같은 클래스 내에서만 접근
    - default : 같은 패키지 내에서만 접근
    - protected : 같은 패키지내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능
    - public : 접근 제한 없음
클래스 -> public , default 사용가능
메서드, 멤버변수 -> public, protected, default, private 사용가능
지역변수 -> 없음

접근 제어자 사용 이유 -> 외부로부터 데이터 보호, 외부에 불필요한 내부적으로만 사용되는 부분을 감추기 위해서

생성자의 접근제어자 - 생성자의 접근제어자를 private 로 지정하면 외부에서 생성자에 접근할 수 없음 -> 인스턴스를 생성할 수 없음
                클래스 내부에서는 인스턴스를 생성할 수 있음 -> 인스턴스를 생성해서 반환해주는 public 메서드를 제공함으로써 외부에서 이 클래스의 인스턴스를 사용할 수 있도록 처리할 수 있음
                private static(내부에서 생성), public static(외부에서 호출) 사용

제어자의 조합
    - 메서드에서 static 과 abstract 를 동시에 사용할 수 없다.
    - 클래스에 abstract 와 final 을 동시에 사용할 수 없다.
    - abstract 메서드의 접근제어자가 private 일 수 없다. (자손클래스에서 접근 불가능하기 때문)
    - 메서드에서 private 와 final을 같이 사용할 필요는 없다. ( 접근제어자가 private인 메서드는 오버라이딩이 될 수 없기 때문 )
    


